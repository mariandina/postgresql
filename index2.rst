POSTGRESQL
==========

1) FUNDAMENTALS
===============

* **IMPORT DATABASE on pgAdminIII**::

    * create a database having similar name with the original database
    * right click on created database - restore
    * select tar archive with old database
    * at the final of restoring must have the message "finished with code 0"
    * ALL OK

* **DATATYPES**
  

Name	       Storage Size                Description	                                                                 Range
smallint	  2 bytes	       small-range integer                                                         -32768 to +32767
integer	          4 bytes	     typical choice for integer	                                              -2147483648 to +2147483647
bigint	          8 bytes	       large-range integer	                                       -9223372036854775808 to 9223372036854775807
decimal	          variable	   user-specified precision, exact	            up to 131072 digits before the decimal point; up to 16383 digits after the decimal point
numeric	          variable	   user-specified precision, exact	            up to 131072 digits before the decimal point; up to 16383 digits after the decimal point
real	          4 bytes	      variable-precision, inexact	                                      6 decimal digits precision
double precision  8 bytes	      variable-precision, inexact	                                      15 decimal digits precision
serial	          4 bytes	      autoincrementing integer	                                                    1 to 2147483647
bigserial	  8 bytes	      large autoincrementing integer	                                       1 to 9223372036854775807

* **SELECT **
* To query data from all rows and all columns from the customer table, you use the following query:
* ``SELECT * FROM customer;``
* Suppose you just need to know first name, last name and email of customers, you can list the column names in the SELECT statement as follows:
* ``SELECT first_name,last_name,email FROM customer;``

* **SELECT DISTINCT**
* The DISTINCT clause is used in the SELECT statement to remove duplicate rows from a result set. The DISTINCT clause keeps one row for each group of duplicates. You can use the DISTINCT clause on one or more columns of a table.
* ``SELECT DISTINCT column_1 FROM table_name;``
* If you specify multiple columns, the DISTINCT clause will evaluate the duplicate based on the combination of values of those columns.
* ``SELECT DISTINCT column_1, column_2 FROM tbl_name;``
* PostgreSQL also provides the DISTINCT ON (expression) to keep the “first” row of each group of duplicates where the expression is equal. See the following syntax:
* ``SELECT DISTINCT ON (column_1) column_1, column_2 FROM tbl_name ORDER BY column_1, column_2;``
* The order of rows returned from the SELECT statement is unpredictable therefore the “first” row of each group of the duplicate is also unpredictable. It is good practice to always use the ORDER BY clause with the DISTINCT  ON(expression) to make the result obvious.

* **ORDER BY Clause**
* The ORDER BY clause allows you to sort the rows returned from the SELECT statement in ascending or descending order based on criteria specified by different criteria.
* ``SELECT column_1, column_2 FROM tbl_name ORDER BY column_1 ASC, column_2 DESC;``

* **WHERE Clause**
* ``SELECT column_1, column_2 … column_n FROM table_name WHERE conditions;``
     OPERATOR	DESCRIPTION
        =	Equal
        >	Greater than
        <	Less than
        >=	Greater than or equal
        <=	Less than or equal
      <> or !=	Not equal
        AND	Logical operator AND
        OR	Logical operator OR
* ``SELECT last_name, first_name FROM customer WHERE first_name = 'Jamie' AND last_name = 'Rice';``
* ``SELECT last_name, first_name FROM customer WHERE first_name = 'Jamie' AND last_name = 'Rice';``
* ``SELECT customer_id, amount, payment_date FROM payment WHERE amount <= 1 OR amount >= 8;``

* **LIMIT Clause**
* ``SELECT * FROM TABLE LIMIT n;``
* PostgreSQL returns n number of rows generated by the query. If n is zero or NULL, it produces the result that is same as omitting the LIMIT clause.
* In case you want to skip a number of rows before returning n rows, you use OFFSET clause followed by the LIMIT clause as follows:
  ``SELECT * FROM table LIMIT n OFFSET m;``
  Example: To get the first 5 films ordered by film_id, you use the following query:
  ``SELECT film_id, title, release_year FROM film ORDER BY film_id LIMIT 5;``
* To retrieve 4 films starting from the third one ordered by film_id, you use both LIMIT and OFFSET clauses as follows: 
  ``SELECT film_id, title, release_year FROM film ORDER BY film_id LIMIT 4 OFFSET 3;``
* We often use the LIMIT clause to get the number of highest or lowest items in a table. For example, to get top 10 most expensive films, we can use the LIMIT clause to get 10 films order by the rental rate in descending order.
  ``SELECT film_id, title, rental_rate FROM film ORDER BY rental_rate DESC LIMIT 10;``

* **IN Clause**
* You use the IN operator in the WHERE clause to check if a value matches any value in a list of values. The syntax of the IN operator is as follows:
  ``SELECT customer_id, rental_id, return_date FROM rental WHERE customer_id IN (1, 2) ORDER BY return_date DESC;``
* You can use the equal (=) and OR operators to rewrite the query above as follows:
  ``SELECT rental_id, customer_id, return_date FROM rental WHERE customer_id = 1 OR customer_id = 2 ORDER BY return_date DESC;``
* You can combine the IN operator with the NOT operator to select rows whose values do not match the values in the list. The following statement selects rentals of customers whose customer id is not 1 or 2.
  ``SELECT customer_id, rental_id, return_date FROM rental WHERE customer_id NOT IN (1, 2);``
* You can also rewrite the NOT IN operator by using the not equal (<>) and the AND operators as follows:
  ``SELECT customer_id, rental_id, return_date FROM rental WHERE customer_id <> 1 AND customer_id <> 2;``
* PostgreSQL IN with subquery: The following query returns a list of customer id of customers that has rental’s return date on 2005-05-27:
  ``SELECT customer_id FROM rental WHERE CAST (return_date AS DATE) = '2005-05-27'``
* You can use the list of customer ids as the input for the IN operator as follows:
  ``SELECT first_name, last_name FROM customer WHERE customer_id IN ( SELECT customer_id FROM rental WHERE CAST (return_date AS DATE) = '2005-05-27');``

* **BETWEEN**
* SELECT customer_id, payment_id, amount FROM payment WHERE amount BETWEEN 8 AND 9;
* SELECT customer_id, payment_id, amount FROM payment WHERE amount NOT BETWEEN 8 AND 9;
* SELECT customer_id, payment_id, amount, payment_date FROM payment WHERE payment_date BETWEEN '2007-02-07' AND '2007-02-15';

* **LIKE clause** Suppose the store manager asks you to find a customer that he does not remember the name exactly. He just remembers that customer’s first name begins with something like Jen. How do you find the exact customer that the store manager is asking? You may find the customer in the customer table by looking at the first name column to see if there is any value that begins with Jen. It is kind of tedious because there many rows in the customertable.
* SELECT first_name, last_name FROM customer WHERE first_name LIKE 'Jen%';
You construct a pattern by combining a string with wildcard characters and use the LIKE or NOT LIKE operator to find the matches. PostgreSQL provides two wildcard characters:
- Percent ( % )  for matching any sequence of characters.
- Underscore ( _ )  for matching any single character.
The following query returns customers whose first name contains  er string e.g., Jenifer, Kimberly, etc.
* SELECT first_name, last_name FROM customer WHERE first_name LIKE '%er%'
You can combine the percent ( %) with underscore ( _) to construct a pattern as the following example:
* SELECT first_name, last_name FROM customer WHERE first_name LIKE '_her%';
The following query returns customer whose first name does not begin with Jen:
* SELECT first_name, last_name FROM customer WHERE first_name NOT LIKE 'Jen%';
PostgreSQL provides the ILIKE operator that acts like the LIKE operator. In addition, the ILIKE operator matches value case-insensitively.
* SELECT first_name, last_name FROM customer WHERE first_name ILIKE 'BAR%';
PostgreSQL also provides some operators that act like the LIKE, NOT LIKE, ILIKE and NOT ILIKE operator as shown below:
~~ is equivalent to LIKE
~~* is equivalent to ILIKE
!~~ is equivalent to NOT LIKE
!~~* is equivalent to NOT ILIKE
_________________________________________________________________________________________________________________________________________________________________________________
* **INNER JOIN**

* Suppose you want to get data from two tables named A and B.
* The B table has the fkafield that relates to the primary key of the A table.

  A         B 
 pka       pkb
 c1         c2
           fka     

To get data from both tables, you use the INNER JOIN clause in the SELECT statement as follows:

*SELECT A.pka, A.c1, B.pkb, B.c2 FROM A INNER JOIN B ON A .pka = B.fka;*
*SELECT A.pka, A.c1, B.pkb, B.c2 FROM A INNER JOIN B ON A .pka = B.fka ORDER BY B.fka;*
*SELECT A.pka, A.c1, B.pkb, B.c2 FROM A INNER JOIN B ON A .pka = B.fka WHERE B.fka = 2;*

To join A table to B table:

* First, you specify the column in both tables from which you want to select data in the SELECT clause. 
* Second, you specify the main table i.e., A in the FROM clause.
* Third, you specify the table that the main table joins to i.e., B in the INNER JOIN clause. 
* In addition, you put a join condition after the ON keyword i.e, A.pka = B.fka.
* For each row in the A table, PostgreSQL scans the B table to check if there is any row that matches the condition i.e., A.pka = B.fka. 
* If it finds a match, it combines columns of both rows into one row and add the combined row to the returned result set.
* The primary key column (pka) and foreign key column (fka) are typically indexed; therefore, PostgreSQL only has to check for the match in the indexes, which is very fast.
* Sometimes A and  B tables have the same column name so we have to refer to the column as table_name.column_name to avoid ambiguity. 
* In case the name of the table is long, you can use a table alias e.g., tbland refer to the column as tbl.column_name.
_________________________________________________________________________________________________________________________________________________________________________________
* **LEFT JOIN**

* Having the same table as below:
* The data in the B table relates to the data in the A table via the fkafield.
* If you want to select rows from the A table which may or may not have corresponding rows in the B table, you use the LEFT JOIN clause. In case, there is no matching row in the B table, the values of the columns in the B table are substituted by the NULL values.

*SELECT A.pka, A.c1, B.pkb, B.c2 FROM A LEFT JOIN B ON A .pka = B.fka;*

To join the A table to the B table, you need to:
* Specify the columns from which you want to select data in the SELECT clause.
* Specify the left table i.e., A table where you want to get all rows, in the FROM clause.
* Specify the right table i.e., B table in the LEFT JOIN clause. In addition, specify the condition for joining two tables.
* The LEFT JOIN clause returns all rows in the left table ( A) that are combined with rows in the right table ( B) even though there is no corresponding rows in the right table ( B). The LEFT JOIN is also referred as LEFT OUTER JOIN.
________________________________________________________________________________________________________________________________________________________________________________
* **FULL OUTER JOIN**

Suppose, you want to perform a full outer join of two tables: A and B. The following illustrates the syntax of the FULL OUTER JOIN:

*SELECT * FROM A FULL [OUTER] JOIN B on A.id = B.id;*

* The OUTER keyword is optional.
* The full outer join combines the results of both left  join and right join. 
* If the rows in the joined table do not match, the full outer join sets NULL values for every column of the table that lacks a matching row. *
* For the matching rows , a single row is included in the result set that contains columns populated from both joined tables.
________________________________________________________________________________________________________________________________________________________________________________

* **CROSS JOIN**
A CROSS JOIN clause allows you to produce the Cartesian Product of rows in two or more tables. 
* Different from the other JOIN operators such as LEFT JOIN  or INNER JOIN, the CROSS JOIN does not have any matching condition in the join clause.
* Suppose we have to perform the CROSS JOIN of two tables T1 and T2. For every row from T1 and T2 i.e., a cartesian product, the result set will contain a row that consists of all columns in the T1 table followed by all columns in the T2 table. If T1 has N rows, T2 has M rows, the result set will have N x M rows.

*SELECT * FROM T1 CROSS JOIN T2;*
*SELECT * FROM T1, T2;*
*SELECT * FROM T1 INNER JOIN T2 ON TRUE;*
________________________________________________________________________________________________________________________________________________________________________________
* **NATURAL JOIN**
* A natural join is a join that creates an implicit join based on the same column names in the joined tables.

*SELECT * FROM T1 NATURAL [INNER, LEFT, RIGHT] JOIN T2;*

A natural join can be an inner join, left join, or right join. If you do not specify a join explicitly e.g., INNER JOIN, LEFT JOIN, RIGHT JOIN, PostgreSQL will use the INNER JOIN by default. The convenience of the NATURAL JOIN is that it does not require you to specify the join clause because it uses an implicit join clause based on the common column.
However, you should avoid using the NATURAL JOIN whenever possible because sometimes it may cause an unexpected result.
________________________________________________________________________________________________________________________________________________________________________________

* **GROUP BY**

The GROUP BY clause divides the rows returned from the SELECT statement into groups. For each group, you can apply an aggregate function e.g., to calculate the sum of items or count the number of items in the groups.

* SELECT column_1, aggregate_function(column_2)
* FROM tbl_name
* GROUP BY column_1;

Let’s take a look at the payment table in the sample database.

payment

payment_id
customer_id
staff_id
rental_id
amount
payment_date

* SELECT customer_id FROM payment GROUP BY customer_id;
* For example, to get how much a customer has been paid, you use the GROUP BY clause to divide the paymentstable into groups; for each group, you calculate the total amounts of money by using the SUM function:
* SELECT customer_id, SUM (amount) FROM payment GROUP BY customer_id;
* The GROUP BY clause sorts the result set by customer id and adds up the amount that belongs to the same customer. Whenever the customer id changes, it adds the row to the returned result set.
* SELECT customer_id, SUM (amount) FROM payment GROUP BY customer_id ORDER BY SUM (amount) DESC;

* SELECT staff_id, COUNT (payment_id) FROM payment GROUP BY staff_id;
The GROUP BY clause sorts the result set by staff id. It keeps a running total of rows, and whenever the staff id changes, it adds the row to the returned result set.

* **HAVING**
We often use the HAVING clause in conjunction with the GROUP BY clause to filter group rows that do not satisfy a specified condition.
* SELECT column_1, aggregate_function (column_2) FROM tbl_name GROUP BY column_1 HAVING condition;
The HAVING clause sets the condition for group rows created by the GROUP BY clause after the GROUP BY clause applies while the WHERE clause sets the condition for individual rows before GROUP BY clause applies. This is the main difference between the HAVING and WHERE clauses.
In PostgreSQL, you can use the HAVING clause without the GROUP BY clause. In this case, the HAVING clause will turn the query into a single group. In addition, the SELECT list and HAVING clause can only refer to columns from within aggregate functions. This kind of query returns a single row if the condition in the HAVING clause is true or zero row if it is false.

* SELECT customer_id, SUM (amount) FROM payment GROUP BY customer_id;
* Selects the only customer who has been spending more than 20 0as the following query:
* SELECT customer_id, SUM (amount) FROM payment GROUP BY customer_id HAVING SUM (amount) > 200;
* The following query returns the number of customers per store:
* SELECT store_id, COUNT (customer_id) FROM customer GROUP BY store_id
* You can use the HAVING clause to select store that has more than 300 customers:
* SELECT store_id, COUNT (customer_id) FROM customer GROUP BY store_id HAVING COUNT (customer_id) > 300;

* **UNION**

- The UNION operator combines result sets of two or more SELECT statements into a single result set.
- The following illustrates the syntax of the UNION operator that combines result sets from two queries:
* SELECT column_1, column_2 FROM tbl_name_1 UNION SELECT column_1, column_2 FROM tbl_name_2;
- The following are rules applied to the queries:
- Both queries must return the same number of columns.
- The corresponding columns in the queries must have compatible data types.
- The UNION operator removes all duplicate rows unless the UNION ALL is used.
- The UNION operator may place the rows in the first query before, after or between the rows in the result set of the second query. To sort the rows in the combined result set by a specified column, you use the ORDER BY clause.
- We often use the UNION operator to combine data from similar tables that are not perfectly normalized. Those tables are often found in the reporting or data warehouse system.

*EXAMPLE*

- sales2007q1: stores sales data in Q1 2007.
  
  name            amount

  Mike          150000.25
  Jon           132000.75
  Mary          100000

- sales2007q2: stores sales data in Q2 2007.

  name            amount

  Mike          120000.25
  Jon           142000.75
  Mary          100000

* UNION:

* SELECT * FROM sales2007q1 UNION SELECT * FROM sales2007q2;

There are five rows in the combined result set because the UNION operator removes one duplicate row. To get all rows that include duplicate, you use the UNION ALL operator as follows:

* SELECT * FROM sales2007q1 UNION ALL SELECT * FROM sales2007q2;

To sort the combined result returned by the UNION operator, you use the ORDER BY clause. You need to put the ORDER BY clause at the last query as the following statement:

* SELECT * FROM sales2007q1 UNION ALL SELECT * FROM sales2007q2 ORDER BY name ASC, amount DESC;

* **INTERSECT**

Like the UNION and EXCEPT operators, the PostgreSQL INTERSECT operator combines the result sets of two or more SELECT statements into a single result set. The INTERSECT operator returns all rows in the both result sets.

SELECT column_list FROM A INTERSECT SELECT column_list FROM B;

To use the INTERSECT operator, the columns that appear in the SELECT statements must follow the rules below:

The number of columns and their order in the SELECT clauses must the be the same.
The data types of the columns must be compatible.

* **EXCEPT**

Return the rows in the first query that do not appear in the output of the second query. Like the UNION and INTERSECT operators, the EXCEPT operator returns rows by comparing the result sets of two or more quires.

The EXCEPT operator returns distinct rows from the first (left) query that are not in the output of the second (right) query. The following illustrates the syntax of the EXCEPT operator.

SELECT column_list FROM A WHERE condition_a EXCEPT SELECT column_list FROM B WHERE condition_b;

* **SUBQUERY**

Find the average rental rate by using the SELECT statement and average function (AVG).
Use the result of the first query in the second SELECT statement to find the films that we want.

SELECT film_id, title, rental_rate FROM film WHERE rental_rate > ( SELECT AVG (rental_rate) FROM film );

The query inside the brackets is called a subquery or an inner query. The query that contains the subquery is known as an outer query.

PostgreSQL executes the query that contains a subquery in the following sequence:

- First, executes the subquery.
- Second, gets the result and passes it to the outer query.
- Third, executes the outer query.

A subquery can return zero or more rows. To use this subquery, you use the IN operator in the WHERE clause.
For example, to get films that have the returned date between 2005-05-29 and 2005-05-30, you use the following query:

SELECT inventory.film_id FROM rental INNER JOIN inventory ON inventory.inventory_id = rental.inventory_id WHERE return_date BETWEEN '2005-05-29' AND '2005-05-30';

It returns multiple rows so we can use this query as a subquery in the WHERE clause of a query as follows:

SELECT film_id, title FROM film WHERE film_id IN ( SELECT inventory.film_id FROM rental INNER JOIN inventory ON inventory.inventory_id = rental.inventory_id WHERE return_date BETWEEN '2005-05-29' AND '2005-05-30' );

A subquery can be an input of the EXISTS operator. If the subquery returns any row, the EXISTS operator returns true. If the subquery returns no row, the result of EXISTS operator is false.

SELECT first_name, last_name FROM customer WHERE EXISTS ( SELECT * FROM payment WHERE payment.customer_id = customer.customer_id );

* **INSERT**

INSERT INTO table(column1, column2, …)
VALUES
(value1, value2, …);

*ADD MULTIPLE ROWS:*
INSERT INTO table (column1, column2, …)
VALUES
 (value1, value2, …),
 (value1, value2, …) ,...;

*To insert data that comes from another table, you use the INSERT INTO SELECT statement as follows:*
INSERT INTO table(value1,value2,...)
SELECT column1,column2,...
FROM another_table
WHERE condition;




                                                   






















































































